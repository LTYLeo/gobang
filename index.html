<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sigma Gobang</title>
    <style>
        :root {
            --primary-color: #10a37f;
            --primary-hover: #0d8c6c;
            --bg-color: #f7f7f8;
            --card-bg: #ffffff;
            --text-color: #343541;
            --border-color: #e5e5e7;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            flex: 1;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        h1 {
            color: var(--primary-color);
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #6e6e80;
            font-size: 1.1rem;
        }

        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
        }

        .game-board-container {
            flex: 1;
            min-width: 500px;
            max-width: 600px;
        }

        .game-info {
            flex: 1;
            min-width: 300px;
            max-width: 400px;
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 10px;
            box-shadow: var(--shadow);
            padding: 25px;
            margin-bottom: 20px;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            gap: 1px;
            background-color: #deb887;
            border: 2px solid #8b4513;
            padding: 10px;
            border-radius: 5px;
            margin: 0 auto;
            max-width: 500px;
            max-height: 500px;
            position: relative;
        }

        .cell {
            aspect-ratio: 1/1;
            background-color: #deb887;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
        }

        .cell::before {
            content: "";
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            z-index: 1;
        }

        .cell.player::before {
            background-color: #000000;
        }

        .cell.ai::before {
            background-color: #ffffff;
            border: 1px solid #333;
        }

        .cell.last-move::after {
            content: "";
            position: absolute;
            width: 30%;
            height: 30%;
            border-radius: 50%;
            background-color: red;
            z-index: 2;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            background-color: var(--primary-color);
            color: white;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn:hover {
            background-color: var(--primary-hover);
        }

        .btn-secondary {
            background-color: #ececf1;
            color: var(--text-color);
        }

        .btn-secondary:hover {
            background-color: #d9d9e3;
        }

        .btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .status {
            padding: 15px;
            border-radius: 5px;
            background-color: #f0f0f0;
            margin-bottom: 20px;
            text-align: center;
            font-weight: bold;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .thinking {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid transparent;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .mode-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .mode-btn {
            padding: 15px;
            text-align: center;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn:hover {
            border-color: var(--primary-color);
            background-color: rgba(16, 163, 127, 0.05);
        }

        .mode-btn.active {
            border-color: var(--primary-color);
            background-color: rgba(16, 163, 127, 0.1);
        }

        .history {
            max-height: 200px;
            overflow-y: auto;
        }

        .history-item {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.9rem;
        }

        .history-item:last-child {
            border-bottom: none;
        }

        footer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
            color: #6e6e80;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .game-board-container, .game-info {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Sigma Gobang</h1>
            <p class="subtitle">Sigma Gobang项目的网页端</p>
        </header>

        <div class="main-content">
            <div class="game-board-container">
                <div class="card">
                    <h2>游戏棋盘</h2>
                    <div class="game-board" id="chessboard">
                        <!-- 棋盘将通过JavaScript动态生成 -->
                    </div>
                </div>
                
                <div class="card">
                    <div class="status" id="gameStatus">请选择游戏模式开始游戏</div>
                    <div class="controls">
                        <button class="btn" id="restartBtn">重新开始</button>
                        <button class="btn btn-secondary" id="undoBtn">悔棋</button>
                        <button class="btn btn-secondary" id="hintBtn">提示</button>
                    </div>
                </div>
            </div>

            <div class="game-info">
                <div class="card">
                    <h2>游戏模式</h2>
                    <div class="mode-selector">
                        <div class="mode-btn active" data-mode="pvc">玩家 vs Sigma Gobang</div>
                        <div class="mode-btn" data-mode="pvp">玩家 vs 玩家</div>
                    </div>
                </div>

                <div class="card">
                    <h2>游戏规则</h2>
                    <p>五子棋是一种两人对弈的纯策略型棋类游戏。双方分别使用黑白两色棋子，下在棋盘直线与横线的交叉点上，先形成五子连线者获胜。</p>
                    <p>在本游戏中，玩家使用黑色棋子(O)，电脑使用白色棋子(X)。</p>
                </div>

                <div class="card">
                    <h2>操作历史</h2>
                    <div class="history" id="moveHistory">
                        <!-- 历史记录将通过JavaScript动态生成 -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer>
        © TAI Research · Sigma Gobang
    </footer>

    <script>
        // 游戏常量
        const BOARD_SIZE = 15;
        const EMPTY = ' ';
        const PLAYER = 'O';
        const AI = 'X';

        // 位置价值表
        const POSITION_VALUE = [
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0],
            [0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 0],
            [0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 3, 2, 1, 0],
            [0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 4, 3, 2, 1, 0],
            [0, 1, 2, 3, 4, 5, 6, 6, 6, 6, 5, 4, 3, 2, 1, 0],
            [0, 1, 2, 3, 4, 5, 6, 7, 7, 6, 5, 4, 3, 2, 1, 0],
            [0, 1, 2, 3, 4, 5, 6, 7, 7, 6, 5, 4, 3, 2, 1, 0],
            [0, 1, 2, 3, 4, 5, 6, 6, 6, 6, 5, 4, 3, 2, 1, 0],
            [0, 1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 4, 3, 2, 1, 0],
            [0, 1, 2, 3, 4, 4, 4, 4, 4, 4, 4, 4, 3, 2, 1, 0],
            [0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 1, 0],
            [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0],
            [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
            [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        ];

        // 游戏状态
        let gameState = {
            board: [],
            currentPlayer: PLAYER,
            gameMode: 'pvc', // pvc: 玩家vs电脑, pvp: 玩家vs玩家
            gameOver: false,
            stepCount: 0,
            lastMove: {x: -1, y: -1},
            moveHistory: [],
            isThinking: false,
            hintPosition: null
        };

        // DOM元素
        const chessboard = document.getElementById('chessboard');
        const gameStatus = document.getElementById('gameStatus');
        const restartBtn = document.getElementById('restartBtn');
        const undoBtn = document.getElementById('undoBtn');
        const hintBtn = document.getElementById('hintBtn');
        const modeButtons = document.querySelectorAll('.mode-btn');
        const moveHistory = document.getElementById('moveHistory');

        // 初始化游戏
        function initGame() {
            // 初始化棋盘
            gameState.board = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                gameState.board[i] = [];
                for (let j = 0; j < BOARD_SIZE; j++) {
                    gameState.board[i][j] = EMPTY;
                }
            }
            
            gameState.currentPlayer = PLAYER;
            gameState.gameOver = false;
            gameState.stepCount = 0;
            gameState.lastMove = {x: -1, y: -1};
            gameState.moveHistory = [];
            gameState.isThinking = false;
            gameState.hintPosition = null;
            
            updateMoveHistory();
            renderBoard();
            updateStatus();
            
            // 启用按钮
            restartBtn.disabled = false;
            undoBtn.disabled = false;
            hintBtn.disabled = false;
        }

        // 渲染棋盘
        function renderBoard() {
            chessboard.innerHTML = '';
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    // 标记最后一步
                    if (i === gameState.lastMove.x && j === gameState.lastMove.y) {
                        cell.classList.add('last-move');
                    }
                    
                    // 标记提示位置
                    if (gameState.hintPosition && i === gameState.hintPosition.x && j === gameState.hintPosition.y) {
                        cell.style.boxShadow = 'inset 0 0 0 2px #ff0000';
                    }
                    
                    // 添加棋子
                    if (gameState.board[i][j] === PLAYER) {
                        cell.classList.add('player');
                    } else if (gameState.board[i][j] === AI) {
                        cell.classList.add('ai');
                    }
                    
                    // 添加点击事件
                    if (!gameState.gameOver && !gameState.isThinking) {
                        cell.addEventListener('click', () => handleCellClick(i, j));
                    }
                    
                    chessboard.appendChild(cell);
                }
            }
        }

        // 处理单元格点击
        function handleCellClick(row, col) {
            if (gameState.gameOver || gameState.board[row][col] !== EMPTY || gameState.isThinking) {
                return;
            }
            
            // 玩家落子
            if (gameState.currentPlayer === PLAYER) {
                makeMove(row, col, PLAYER);
                
                // 检查游戏是否结束
                if (checkWin(row, col, PLAYER)) {
                    gameState.gameOver = true;
                    updateStatus();
                    return;
                }
                
                // 切换玩家或AI回合
                if (gameState.gameMode === 'pvc') {
                    gameState.currentPlayer = AI;
                    updateStatus();
                    
                    // AI落子（延迟一下，让玩家看到自己的棋子）
                    setTimeout(makeAIMove, 500);
                } else {
                    gameState.currentPlayer = AI; // 在PVP模式下，AI代表第二个玩家
                    updateStatus();
                }
            } else if (gameState.gameMode === 'pvp') {
                // PVP模式下的第二个玩家
                makeMove(row, col, AI);
                
                // 检查游戏是否结束
                if (checkWin(row, col, AI)) {
                    gameState.gameOver = true;
                    updateStatus();
                    return;
                }
                
                gameState.currentPlayer = PLAYER;
                updateStatus();
            }
        }

        // 落子
        function makeMove(row, col, player) {
            gameState.board[row][col] = player;
            gameState.stepCount++;
            gameState.lastMove = {x: row, y: col};
            gameState.hintPosition = null; // 清除提示
            
            // 记录历史
            gameState.moveHistory.push({
                player: player,
                position: {x: row, y: col},
                step: gameState.stepCount
            });
            
            updateMoveHistory();
            renderBoard();
        }

        // AI落子 - 修复版本
        function makeAIMove() {
            if (gameState.gameOver) return;
            
            gameState.isThinking = true;
            updateStatus();
            
            // 延迟执行，让UI有时间更新
            setTimeout(() => {
                let bestMove = {x: 0, y: 0};
                
                // 第一步下在中心
                if (gameState.stepCount === 1) {
                    bestMove.x = Math.floor(BOARD_SIZE / 2);
                    bestMove.y = Math.floor(BOARD_SIZE / 2);
                } else {
                    // 1. 检查是否有立即获胜的机会
                    const immediateWin = findImmediateWin(AI);
                    if (immediateWin) {
                        bestMove = immediateWin;
                    } else {
                        // 2. 检查是否需要立即防守（玩家有活四、冲四或双活三等威胁）
                        const criticalDefense = findCriticalDefensiveMove();
                        if (criticalDefense) {
                            bestMove = criticalDefense;
                        } else {
                            // 3. 多步预判：评估所有可能位置
                            bestMove = findBestMove();
                        }
                    }
                }
                
                makeMove(bestMove.x, bestMove.y, AI);
                
                // 检查游戏是否结束
                if (checkWin(bestMove.x, bestMove.y, AI)) {
                    gameState.gameOver = true;
                    gameState.isThinking = false;
                    updateStatus();
                    return;
                }
                
                gameState.currentPlayer = PLAYER;
                gameState.isThinking = false;
                updateStatus();
                renderBoard(); // 重新渲染棋盘以启用点击事件
            }, 500);
        }

        // 寻找立即获胜的机会
        function findImmediateWin(player) {
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (gameState.board[i][j] === EMPTY) {
                        gameState.board[i][j] = player;
                        if (checkWin(i, j, player)) {
                            gameState.board[i][j] = EMPTY;
                            return {x: i, y: j};
                        }
                        gameState.board[i][j] = EMPTY;
                    }
                }
            }
            return null;
        }

        // 寻找关键防守位置（活四、冲四、双活三等）
        function findCriticalDefensiveMove() {
            const opponent = PLAYER;
            let maxThreat = 0;
            let bestDefense = null;
            
            // 扫描整个棋盘寻找威胁
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (gameState.board[i][j] === EMPTY) {
                        const threatLevel = evaluateThreatLevel(i, j, opponent);
                        if (threatLevel > maxThreat) {
                            maxThreat = threatLevel;
                            bestDefense = {x: i, y: j};
                        }
                    }
                }
            }
            
            // 如果有高威胁（活四、冲四、双活三），则防守
            if (maxThreat >= 10000) {
                return bestDefense;
            }
            
            return null;
        }

        // 评估威胁级别
        function evaluateThreatLevel(x, y, player) {
            gameState.board[x][y] = player;
            let threatLevel = 0;
            
            // 检查直接获胜威胁
            if (checkWin(x, y, player)) {
                threatLevel = 20000; // 最高级别威胁
                gameState.board[x][y] = EMPTY;
                return threatLevel;
            }
            
            // 检查活四威胁
            if (checkOpenFour(x, y, player)) {
                threatLevel = Math.max(threatLevel, 15000);
            }
            // 检查冲四威胁
            else if (checkHalfOpenFour(x, y, player)) {
                threatLevel = Math.max(threatLevel, 10000);
            }
            // 检查双活三威胁
            else if (checkDoubleOpenThree(x, y, player)) {
                threatLevel = Math.max(threatLevel, 8000);
            }
            // 检查活三威胁
            else if (checkOpenThree(x, y, player)) {
                threatLevel = Math.max(threatLevel, 5000);
            }
            
            gameState.board[x][y] = EMPTY;
            return threatLevel;
        }

        // 寻找最佳落子位置
        function findBestMove() {
            let bestScore = -Infinity;
            let bestMove = {x: 0, y: 0};
            const candidateMoves = [];
            
            // 获取所有候选位置（只考虑有棋子周围的区域）
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (gameState.board[i][j] === EMPTY && hasNeighbor(i, j, 2)) {
                        candidateMoves.push({x: i, y: j});
                    }
                }
            }
            
            // 如果没有候选位置，随机选择
            if (candidateMoves.length === 0) {
                while (true) {
                    const x = Math.floor(Math.random() * BOARD_SIZE);
                    const y = Math.floor(Math.random() * BOARD_SIZE);
                    if (gameState.board[x][y] === EMPTY) {
                        return {x, y};
                    }
                }
            }
            
            // 评估每个候选位置
            for (const move of candidateMoves) {
                let score = evaluatePosition(move.x, move.y, AI, PLAYER);
                
                // 多步预判：考虑对手的应对
                gameState.board[move.x][move.y] = AI;
                const opponentScore = evaluateBestResponse(PLAYER, AI);
                gameState.board[move.x][move.y] = EMPTY;
                
                // 最终分数 = 我方得分 - 对手得分 * 防御系数
                const finalScore = score - opponentScore * 0.7;
                
                if (finalScore > bestScore) {
                    bestScore = finalScore;
                    bestMove = move;
                }
            }
            
            return bestMove;
        }

        // 评估位置价值（考虑攻防）
        function evaluatePosition(x, y, self, opponent) {
            let score = POSITION_VALUE[x][y]; // 位置基础价值
            
            // 临时放置棋子进行评估
            gameState.board[x][y] = self;
            score += evaluateLine(x, y, self, opponent);
            
            // 评估对手威胁
            gameState.board[x][y] = opponent;
            score += evaluateLine(x, y, opponent, self) * 1.2; // 防守权重更高
            
            gameState.board[x][y] = EMPTY;
            
            return score;
        }
        
        // 评估行、列、对角线的价值
        function evaluateLine(x, y, self, opponent) {
            let score = 0;
            const directions = [[1,0], [0,1], [1,1], [1,-1]]; // 四个方向
            
            for (const [dx, dy] of directions) {
                score += evaluatePattern(x, y, dx, dy, self, opponent);
            }
            
            return score;
        }
        
        // 评估特定方向上的棋型
        function evaluatePattern(x, y, dx, dy, self, opponent) {
            let score = 0;
            let selfCount = 1;  // 当前位置已经假设是self
            let openEnds = 0;
            let leftOpen = true, rightOpen = true;
            
            // 向左检查
            for (let i = 1; i <= 4; i++) {
                const nx = x - i * dx;
                const ny = y - i * dy;
                
                if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
                    leftOpen = false;
                    break;
                }
                
                if (gameState.board[nx][ny] === self) {
                    selfCount++;
                } else if (gameState.board[nx][ny] === opponent) {
                    leftOpen = false;
                    break;
                } else {
                    break; // 空位
                }
            }
            
            // 向右检查
            for (let i = 1; i <= 4; i++) {
                const nx = x + i * dx;
                const ny = y + i * dy;
                
                if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
                    rightOpen = false;
                    break;
                }
                
                if (gameState.board[nx][ny] === self) {
                    selfCount++;
                } else if (gameState.board[nx][ny] === opponent) {
                    rightOpen = false;
                    break;
                } else {
                    break; // 空位
                }
            }
            
            // 计算开放端口
            if (leftOpen) openEnds++;
            if (rightOpen) openEnds++;
            
            // 根据连子数和开放端口评分
            switch (selfCount) {
                case 5: // 五连
                    score += 100000;
                    break;
                case 4:
                    if (openEnds === 2) score += 10000; // 活四
                    else if (openEnds === 1) score += 1000; // 冲四
                    break;
                case 3:
                    if (openEnds === 2) score += 1000; // 活三
                    else if (openEnds === 1) score += 200; // 眠三
                    break;
                case 2:
                    if (openEnds === 2) score += 200; // 活二
                    else if (openEnds === 1) score += 50; // 眠二
                    break;
                case 1:
                    if (openEnds === 2) score += 10; // 单子
                    break;
            }
            
            return score;
        }

        // 评估对手的最佳应对
        function evaluateBestResponse(opponent, self) {
            let bestResponseScore = -Infinity;
            
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (gameState.board[i][j] === EMPTY && hasNeighbor(i, j, 2)) {
                        const score = evaluatePosition(i, j, opponent, self);
                        if (score > bestResponseScore) {
                            bestResponseScore = score;
                        }
                    }
                }
            }
            
            return bestResponseScore;
        }

        // 检查是否有邻居棋子
        function hasNeighbor(x, y, distance) {
            if (gameState.stepCount < 4) return true; // 开局时不需要邻居
            
            for (let dx = -distance; dx <= distance; dx++) {
                for (let dy = -distance; dy <= distance; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE) {
                        if (gameState.board[nx][ny] !== EMPTY) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // 检查是否获胜
        function checkWin(x, y, player) {
            const directions = [[1,0], [0,1], [1,1], [1,-1]];
            
            for (const [dx, dy] of directions) {
                let count = 1; // 当前位置
                
                // 正向检查
                for (let i = 1; i <= 4; i++) {
                    const nx = x + i * dx;
                    const ny = y + i * dy;
                    
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE || 
                        gameState.board[nx][ny] !== player) {
                        break;
                    }
                    count++;
                }
                
                // 反向检查
                for (let i = 1; i <= 4; i++) {
                    const nx = x - i * dx;
                    const ny = y - i * dy;
                    
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE || 
                        gameState.board[nx][ny] !== player) {
                        break;
                    }
                    count++;
                }
                
                if (count >= 5) {
                    return true;
                }
            }
            
            return false;
        }

        // 检查活四
        function checkOpenFour(x, y, player) {
            const directions = [[1,0], [0,1], [1,1], [1,-1]];
            
            for (const [dx, dy] of directions) {
                let count = 1;
                let leftOpen = true, rightOpen = true;
                
                // 向左检查
                for (let i = 1; i <= 4; i++) {
                    const nx = x - i * dx;
                    const ny = y - i * dy;
                    
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
                        leftOpen = false;
                        break;
                    }
                    
                    if (gameState.board[nx][ny] === player) {
                        count++;
                    } else if (gameState.board[nx][ny] !== EMPTY) {
                        leftOpen = false;
                        break;
                    } else {
                        break;
                    }
                }
                
                // 向右检查
                for (let i = 1; i <= 4; i++) {
                    const nx = x + i * dx;
                    const ny = y + i * dy;
                    
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
                        rightOpen = false;
                        break;
                    }
                    
                    if (gameState.board[nx][ny] === player) {
                        count++;
                    } else if (gameState.board[nx][ny] !== EMPTY) {
                        rightOpen = false;
                        break;
                    } else {
                        break;
                    }
                }
                
                if (count === 4 && leftOpen && rightOpen) {
                    return true;
                }
            }
            
            return false;
        }

        // 检查冲四
        function checkHalfOpenFour(x, y, player) {
            const directions = [[1,0], [0,1], [1,1], [1,-1]];
            
            for (const [dx, dy] of directions) {
                let count = 1;
                let leftOpen = false, rightOpen = false;
                
                // 向左检查
                for (let i = 1; i <= 4; i++) {
                    const nx = x - i * dx;
                    const ny = y - i * dy;
                    
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
                        break;
                    }
                    
                    if (gameState.board[nx][ny] === player) {
                        count++;
                    } else if (gameState.board[nx][ny] === EMPTY) {
                        leftOpen = true;
                        break;
                    } else {
                        break;
                    }
                }
                
                // 向右检查
                for (let i = 1; i <= 4; i++) {
                    const nx = x + i * dx;
                    const ny = y + i * dy;
                    
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
                        break;
                    }
                    
                    if (gameState.board[nx][ny] === player) {
                        count++;
                    } else if (gameState.board[nx][ny] === EMPTY) {
                        rightOpen = true;
                        break;
                    } else {
                        break;
                    }
                }
                
                if (count === 4 && (leftOpen || rightOpen)) {
                    return true;
                }
            }
            
            return false;
        }

        // 检查活三
        function checkOpenThree(x, y, player) {
            const directions = [[1,0], [0,1], [1,1], [1,-1]];
            
            for (const [dx, dy] of directions) {
                let count = 1;
                let leftOpen = true, rightOpen = true;
                
                // 向左检查
                for (let i = 1; i <= 3; i++) {
                    const nx = x - i * dx;
                    const ny = y - i * dy;
                    
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
                        leftOpen = false;
                        break;
                    }
                    
                    if (gameState.board[nx][ny] === player) {
                        count++;
                    } else if (gameState.board[nx][ny] !== EMPTY) {
                        leftOpen = false;
                        break;
                    } else {
                        break;
                    }
                }
                
                // 向右检查
                for (let i = 1; i <= 3; i++) {
                    const nx = x + i * dx;
                    const ny = y + i * dy;
                    
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
                        rightOpen = false;
                        break;
                    }
                    
                    if (gameState.board[nx][ny] === player) {
                        count++;
                    } else if (gameState.board[nx][ny] !== EMPTY) {
                        rightOpen = false;
                        break;
                    } else {
                        break;
                    }
                }
                
                if (count === 3 && leftOpen && rightOpen) {
                    return true;
                }
            }
            
            return false;
        }

        // 检查双活三
        function checkDoubleOpenThree(x, y, player) {
            gameState.board[x][y] = player;
            let openThreeCount = 0;
            
            const directions = [[1,0], [0,1], [1,1], [1,-1]];
            
            for (const [dx, dy] of directions) {
                let count = 1;
                let leftOpen = true, rightOpen = true;
                
                // 向左检查
                for (let i = 1; i <= 3; i++) {
                    const nx = x - i * dx;
                    const ny = y - i * dy;
                    
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
                        leftOpen = false;
                        break;
                    }
                    
                    if (gameState.board[nx][ny] === player) {
                        count++;
                    } else if (gameState.board[nx][ny] !== EMPTY) {
                        leftOpen = false;
                        break;
                    } else {
                        break;
                    }
                }
                
                // 向右检查
                for (let i = 1; i <= 3; i++) {
                    const nx = x + i * dx;
                    const ny = y + i * dy;
                    
                    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
                        rightOpen = false;
                        break;
                    }
                    
                    if (gameState.board[nx][ny] === player) {
                        count++;
                    } else if (gameState.board[nx][ny] !== EMPTY) {
                        rightOpen = false;
                        break;
                    } else {
                        break;
                    }
                }
                
                if (count === 3 && leftOpen && rightOpen) {
                    openThreeCount++;
                }
            }
            
            gameState.board[x][y] = EMPTY;
            return openThreeCount >= 2;
        }

        // 提供提示
        function provideHint() {
            if (gameState.gameOver || gameState.isThinking || gameState.currentPlayer !== PLAYER) {
                return;
            }
            
            const bestMove = findBestMove();
            gameState.hintPosition = bestMove;
            renderBoard();
            
            // 5秒后清除提示
            setTimeout(() => {
                gameState.hintPosition = null;
                renderBoard();
            }, 5000);
        }

        // 更新游戏状态显示
        function updateStatus() {
            if (gameState.isThinking) {
                gameStatus.innerHTML = '<div class="thinking"><div class="spinner"></div>Sigma Gobang 正在思考...</div>';
                return;
            }
            
            if (gameState.gameOver) {
                if (checkWin(gameState.lastMove.x, gameState.lastMove.y, PLAYER)) {
                    gameStatus.textContent = '游戏结束！玩家获胜！';
                } else if (checkWin(gameState.lastMove.x, gameState.lastMove.y, AI)) {
                    if (gameState.gameMode === 'pvc') {
                        gameStatus.textContent = '游戏结束！Sigma Gobang 获胜！';
                    } else {
                        gameStatus.textContent = '游戏结束！玩家2获胜！';
                    }
                } else if (gameState.stepCount === BOARD_SIZE * BOARD_SIZE) {
                    gameStatus.textContent = '游戏结束！平局！';
                }
            } else {
                if (gameState.currentPlayer === PLAYER) {
                    gameStatus.textContent = '当前回合：玩家 (O)';
                } else {
                    if (gameState.gameMode === 'pvc') {
                        gameStatus.textContent = '当前回合：Sigma Gobang (X)';
                    } else {
                        gameStatus.textContent = '当前回合：玩家2 (X)';
                    }
                }
            }
        }

        // 更新历史记录
        function updateMoveHistory() {
            moveHistory.innerHTML = '';
            
            if (gameState.moveHistory.length === 0) {
                const emptyItem = document.createElement('div');
                emptyItem.className = 'history-item';
                emptyItem.textContent = '暂无记录';
                moveHistory.appendChild(emptyItem);
                return;
            }
            
            // 只显示最近10步
            const startIndex = Math.max(0, gameState.moveHistory.length - 10);
            
            for (let i = startIndex; i < gameState.moveHistory.length; i++) {
                const move = gameState.moveHistory[i];
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                
                const playerName = move.player === PLAYER ? '玩家' : 
                                 (gameState.gameMode === 'pvc' ? 'Sigma Gobang' : '玩家2');
                
                historyItem.textContent = `第${move.step}步: ${playerName} 落子于 (${move.position.x + 1}, ${move.position.y + 1})`;
                moveHistory.appendChild(historyItem);
            }
            
            // 滚动到底部
            moveHistory.scrollTop = moveHistory.scrollHeight;
        }

        // 悔棋功能
        function undoMove() {
            if (gameState.moveHistory.length < 1 || gameState.gameOver || gameState.isThinking) {
                return;
            }
            
            // 移除最后一步
            const lastMove = gameState.moveHistory.pop();
            gameState.board[lastMove.position.x][lastMove.position.y] = EMPTY;
            gameState.stepCount--;
            
            // 如果还有上一步，更新最后一步记录
            if (gameState.moveHistory.length > 0) {
                const prevMove = gameState.moveHistory[gameState.moveHistory.length - 1];
                gameState.lastMove = prevMove.position;
            } else {
                gameState.lastMove = {x: -1, y: -1};
            }
            
            // 切换当前玩家
            gameState.currentPlayer = lastMove.player === PLAYER ? AI : PLAYER;
            gameState.gameOver = false;
            
            updateMoveHistory();
            renderBoard();
            updateStatus();
        }

        // 事件监听
        restartBtn.addEventListener('click', initGame);
        
        undoBtn.addEventListener('click', () => {
            if (gameState.gameMode === 'pvc' && gameState.currentPlayer === AI) {
                // 在PVC模式下，如果当前是AI回合，需要悔两步（玩家和AI各一步）
                if (gameState.moveHistory.length >= 2) {
                    undoMove(); // 撤销AI的步
                    undoMove(); // 撤销玩家的步
                }
            } else {
                undoMove();
            }
        });

        hintBtn.addEventListener('click', provideHint);

        // 模式选择
        modeButtons.forEach(button => {
            button.addEventListener('click', () => {
                modeButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                gameState.gameMode = button.dataset.mode;
                initGame();
            });
        });

        // 初始化游戏
        initGame();
    </script>
</body>
</html>
